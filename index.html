<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI ëë§ì‡ê¸° ëŒ€ê²°</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React and Babel for browser execution -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Nanum+Round:wght@400;700;800&display=swap');
        body { font-family: 'Nanum Round', sans-serif; }
        .chat-scroll::-webkit-scrollbar { width: 6px; }
        .chat-scroll::-webkit-scrollbar-track { background: transparent; }
        .chat-scroll::-webkit-scrollbar-thumb { background: #bae6fd; border-radius: 10px; }
    </style>
</head>
<body class="bg-sky-50">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // Lucide Icon Component Wrapper
        const Icon = ({ name, size = 24, className = "" }) => {
            const [svg, setSvg] = useState("");
            useEffect(() => {
                if (window.lucide) {
                    const iconSvg = lucide.createIcons();
                }
            }, []);
            return <i data-lucide={name} style={{ width: size, height: size }} className={className}></i>;
        };

        const App = () => {
            const [history, setHistory] = useState([]);
            const [inputValue, setInputValue] = useState('');
            const [message, setMessage] = useState('ê²Œì„ ì‹œì‘ ë²„íŠ¼ì„ ëˆŒëŸ¬ì£¼ì„¸ìš”!');
            const [isGameOver, setIsGameOver] = useState(true);
            const [score, setScore] = useState(0);
            const [usedWords, setUsedWords] = useState(new Set());
            const scrollRef = useRef(null);

            const wordDb = [
                "ì‚¬ê³¼", "ê³¼ì", "ìì „ê±°", "ê±°ë¯¸", "ë¯¸ì†Œ", "ì†Œë‚˜ë¬´", "ë¬´ì§€ê°œ", "ê°œë¯¸", "ë¯¸ì—­", "ì—­ì‚¬",
                "ì‚¬ì", "ìì„", "ì„ì–‘", "ì–‘íŒŒ", "íŒŒë¦¬", "ë¦¬ë³¸", "ë³¸ì²´", "ì²´ìœ¡", "ìœ¡êµ", "êµì‹¤",
                "ì‹¤ë‚´", "ë‚´ê³¼", "ê³¼ì¼", "ì¼ë³¸", "ë³¸ê²©", "ê²©íŒŒ", "íŒŒë„", "ë„í† ë¦¬", "ë¦¬ë“¬", "ë“¬ì§",
                "ì§ì—…", "ì—…ê·¸ë ˆì´ë“œ", "ë“œë¼ë§ˆ", "ë§ˆìŠ¤í¬", "í¬ë¦¼", "ì„ê¸ˆ", "ê¸ˆë©”ë‹¬", "ë‹¬ë ¥", "ë ¥ì‚¬",
                "ì‚¬íƒ•", "íƒ•ìˆ˜ìœ¡", "ìœ¡ì•„", "ì•„ê¸°", "ê¸°ì°¨", "ì°¨í‘œ", "í‘œë²”", "ë²”ê³ ë˜", "ë˜í¼", "í¼ì¦",
                "ì¦ê±°ì›€", "ì›€ë§‰", "ë§‰ëŒ€ê¸°", "ê¸°êµ¬", "êµ¬ë‘", "ë‘ë¶€", "ë¶€ëª¨", "ëª¨ì", "ììœ ", "ìœ ë¦¬",
                "ìŒì•…", "ì•…ê¸°", "ê¸°ìƒ", "ìƒì", "ìë¼", "ë¼ë””ì˜¤", "ì˜¤ë¦¬", "ë¦¬í„°", "í„°ë„",
                "ë„ë¹¤ì§€", "ì§€êµ¬", "êµ¬ë¦„", "ë¦„ë¦„", "ë¦„ë¦„ì´", "ì´ë¦„", "ìŒë£Œìˆ˜", "ìˆ˜ë°•", "ë°•ìˆ˜", "ìˆ˜ê±´",
                "ê±´ê°•", "ê°•ì•„ì§€", "ì§€ìš°ê°œ", "ê°œë‚˜ë¦¬", "ë“¬ì„±ë“¬ì„±", "ì„±ê³µ", "ê³µë£¡", "ë£¡ì™•", "ì™•ì"
            ];

            const applyDuum = (char) => {
                const rules = {
                    'ë¼': 'ë‚˜', 'ë½': 'ë‚™', 'ë€': 'ë‚œ', 'ë„': 'ë‚ ', 'ëŒ': 'ë‚¨', 'ë': 'ë‚©', 'ë‘': 'ë‚­',
                    'ë˜': 'ë‚´', 'ë­': 'ëƒ‰', 'ë´': 'ì•¼', 'ëµ': 'ì•½', 'ëŸ‰': 'ì–‘', 'ë ¤': 'ì—¬', 'ë ¥': 'ì—­',
                    'ë ¨': 'ì—°', 'ë ¬': 'ì—´', 'ë ´': 'ì—¼', 'ë µ': 'ì—½', 'ë ¹': 'ì˜', 'ë¡€': 'ì˜ˆ', 'ë¡œ': 'ë…¸',
                    'ë¡': 'ë…¹', 'ë¡ ': 'ë…¼', 'ë¡±': 'ë†', 'ë¢°': 'ë‡Œ', 'ë£Œ': 'ìš”', 'ë£¡': 'ìš©', 'ë£¨': 'ëˆ„',
                    'ë¥˜': 'ìœ ', 'ë¥œ': 'ìœ¤', 'ë¥ ': 'ìœ¨', 'ë¥­': 'ìœµ', 'ë¥´': 'ëŠ', 'ë¦¬': 'ì´', 'ë¦°': 'ì¸',
                    'ë¦¼': 'ì„', 'ë¦½': 'ì…'
                };
                return rules[char] || char;
            };

            useEffect(() => {
                if (scrollRef.current) {
                    scrollRef.current.scrollTop = scrollRef.current.scrollHeight;
                }
                if (window.lucide) lucide.createIcons();
            }, [history]);

            const startGame = () => {
                const firstWord = "ì‚¬ê³¼";
                setHistory([{ sender: 'ai', text: firstWord }]);
                setUsedWords(new Set([firstWord]));
                setScore(0);
                setIsGameOver(false);
                setMessage("ë‹¨ì–´ë¥¼ ì…ë ¥í•´ì„œ ëë§ì„ ì´ì–´ê°€ì„¸ìš”!");
                setInputValue('');
            };

            const handleSubmit = (e) => {
                e.preventDefault();
                if (isGameOver || !inputValue.trim()) return;

                const userWord = inputValue.trim();
                const lastWord = history[history.length - 1].text;
                const lastChar = lastWord[lastWord.length - 1];
                const firstChar = userWord[0];

                if (userWord.length < 2) {
                    setMessage("ë‘ ê¸€ì ì´ìƒì˜ ë‹¨ì–´ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”!");
                    return;
                }
                if (usedWords.has(userWord)) {
                    setMessage("ì´ë¯¸ ì‚¬ìš©í•œ ë‹¨ì–´ì˜ˆìš”!");
                    return;
                }
                if (firstChar !== lastChar && firstChar !== applyDuum(lastChar)) {
                    setMessage(`'${lastChar}'(ìœ¼)ë¡œ ì‹œì‘í•˜ëŠ” ë‹¨ì–´ì—¬ì•¼ í•´ìš”!`);
                    return;
                }

                const updatedUsedWords = new Set(usedWords).add(userWord);
                setUsedWords(updatedUsedWords);
                setHistory(prev => [...prev, { sender: 'user', text: userWord }]);
                setScore(prev => prev + 1);
                setInputValue('');
                setMessage("AIê°€ ìƒê° ì¤‘...");

                setTimeout(() => {
                    const nextChar = userWord[userWord.length - 1];
                    const possibleWords = wordDb.filter(w => 
                        (w[0] === nextChar || w[0] === applyDuum(nextChar)) && !updatedUsedWords.has(w)
                    );

                    if (possibleWords.length === 0) {
                        setIsGameOver(true);
                        setMessage("ëŒ€ë‹¨í•´ìš”! AIë¥¼ ì´ê²¼ìŠµë‹ˆë‹¤! ì¶•í•˜í•©ë‹ˆë‹¤! ğŸ‰");
                    } else {
                        const aiWord = possibleWords[Math.floor(Math.random() * possibleWords.length)];
                        setHistory(prev => [...prev, { sender: 'ai', text: aiWord }]);
                        setUsedWords(prev => new Set(prev).add(aiWord));
                        setMessage(`AIê°€ '${aiWord}'ë¼ê³  ë‹µí–ˆìŠµë‹ˆë‹¤. ë‹¤ìŒ ë‹¨ì–´ëŠ”?`);
                    }
                }, 800);
            };

            return (
                <div className="min-h-screen flex flex-col items-center p-4">
                    {/* Header */}
                    <div className="w-full max-w-md bg-white rounded-3xl shadow-lg p-6 mb-4 text-center border-b-4 border-sky-200">
                        <h1 className="text-3xl font-black text-sky-600 flex items-center justify-center gap-2">
                            <i data-lucide="brain" className="w-8 h-8"></i> ëë§ì‡ê¸° ëŒ€ê²°
                        </h1>
                        <div className="mt-2 flex justify-between items-center px-4">
                            <div className="bg-sky-100 px-4 py-1 rounded-full text-sky-700 font-bold">
                                ì ìˆ˜: {score}
                            </div>
                            <button 
                                onClick={startGame}
                                className="flex items-center gap-1 text-sm bg-orange-400 hover:bg-orange-500 text-white px-3 py-1 rounded-full transition-colors font-bold shadow-sm"
                            >
                                <i data-lucide="refresh-cw" className="w-4 h-4"></i> ë‹¤ì‹œ ì‹œì‘
                            </button>
                        </div>
                    </div>

                    {/* Message Area */}
                    <div className="w-full max-w-md bg-white rounded-2xl p-4 mb-4 shadow-sm border-2 border-sky-100 flex items-center gap-3">
                        <i data-lucide="alert-circle" className="text-sky-500 shrink-0"></i>
                        <p className="font-semibold text-sm sm:text-base text-sky-800">{message}</p>
                    </div>

                    {/* Chat Area */}
                    <div 
                        ref={scrollRef}
                        className="w-full max-w-md flex-1 bg-white rounded-3xl shadow-inner border-4 border-white p-4 overflow-y-auto mb-4 space-y-3 min-h-[400px] chat-scroll"
                    >
                        {history.length === 0 && (
                            <div className="h-full flex flex-col items-center justify-center text-gray-300 space-y-4 py-20">
                                <i data-lucide="trophy" className="w-16 h-16 opacity-20"></i>
                                <p className="text-center font-medium">AI ì¹œêµ¬ê°€ ê¸°ë‹¤ë¦¬ê³  ìˆì–´ìš”!<br/>ì‹œì‘ ë²„íŠ¼ì„ ëˆŒëŸ¬ì£¼ì„¸ìš”.</p>
                            </div>
                        )}
                        {history.map((msg, idx) => (
                            <div key={idx} className={`flex ${msg.sender === 'user' ? 'justify-end' : 'justify-start'} items-end gap-2`}>
                                {msg.sender === 'ai' && (
                                    <div className="w-8 h-8 rounded-full bg-sky-500 flex items-center justify-center text-white shrink-0">
                                        <i data-lucide="brain" className="w-5 h-5"></i>
                                    </div>
                                )}
                                <div className={`max-w-[80%] px-5 py-3 rounded-2xl font-bold text-lg shadow-sm ${
                                    msg.sender === 'user' 
                                    ? 'bg-orange-400 text-white rounded-br-none' 
                                    : 'bg-sky-100 text-sky-900 rounded-bl-none'
                                }`}>
                                    {msg.text}
                                </div>
                                {msg.sender === 'user' && (
                                    <div className="w-8 h-8 rounded-full bg-orange-500 flex items-center justify-center text-white shrink-0">
                                        <i data-lucide="user" className="w-5 h-5"></i>
                                    </div>
                                )}
                            </div>
                        ))}
                    </div>

                    {/* Input Area */}
                    <form onSubmit={handleSubmit} className="w-full max-w-md relative">
                        <input
                            type="text"
                            value={inputValue}
                            onChange={(e) => setInputValue(e.target.value)}
                            disabled={isGameOver}
                            placeholder={isGameOver ? "ê²Œì„ì„ ì‹œì‘í•´ì£¼ì„¸ìš”" : "ë‹¨ì–´ë¥¼ ì…ë ¥í•˜ì„¸ìš”!"}
                            className="w-full px-6 py-4 rounded-full border-4 border-sky-200 focus:border-sky-400 focus:outline-none text-xl font-bold shadow-lg disabled:bg-gray-50 transition-all placeholder:text-gray-300"
                        />
                        <button
                            type="submit"
                            disabled={isGameOver}
                            className="absolute right-2 top-2 bottom-2 bg-sky-500 hover:bg-sky-600 disabled:bg-gray-300 text-white px-6 rounded-full transition-all shadow-md flex items-center justify-center"
                        >
                            <i data-lucide="send" className="w-6 h-6"></i>
                        </button>
                    </form>

                    <div className="mt-6 text-xs text-gray-400 text-center max-w-xs leading-relaxed">
                        <p>ğŸ’¡ ê·œì¹™: ë‘ ê¸€ì ì´ìƒ, ë‹¨ì–´ ì¤‘ë³µ ì•ˆë¨, ë‘ìŒë²•ì¹™ í—ˆìš©</p>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>